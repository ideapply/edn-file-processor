# å®Œæˆæ‰€æœ‰æ–‡æœ¬è¯†åˆ«å·¥ä½œï¼Œæš‚æœªå¤„ç†æ’åºé—®é¢˜ 2023-12-22
# å°šå­˜åœ¨BUGï¼šå¯¹å­—æ®µã€Œ{:block/children ...}ã€æŠ¥é”™ï¼Œæ­£åˆ™/æ–‡æœ¬æ›¿æ¢å‡æ— æ³•è§£å†³ï¼›é€šè¿‡æ¸…ç©ºã€Œroam/excalidrawã€é¡µé¢å†…å®¹è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚æœ€æ–°ç‰ˆçš„Timelineå„ä¸ªæœ€æ–°ednå·²ç»å¯ä»¥å®Œå…¨è¯†åˆ«äº†ï¼ŒPrismVisionå†å²ç‰ˆæœ¬éœ€è¦åˆ é™¤è¯¥å­—æ®µæ‰èƒ½æ­£ç¡®ä½¿ç”¨ã€‚
# é€šè¿‡å»é™¤æ–‡æœ¬ã€Œ:entity/attrs #{}ã€å®ç°äº†ã€Œ{:block/children ...}ã€å­—æ®µBUGçš„ä¿®å¤ï¼Œè‡³æ­¤ï¼Œæ‰€æœ‰å†å²ç‰ˆæœ¬ednå‡å®ç°è¯»å–ã€‚ 2023-12-22 20:20
# å½¢å¼ä¸Šå®ç°äº†edn2mdï¼Œæš‚æ—¶è¿˜æœ‰éƒ¨åˆ†æ–‡æœ¬å­˜åœ¨é¡ºåºé—®é¢˜ã€‚ 2023-12-22 22:25
# è§£å†³äº†æ’åºé—®é¢˜ 2023-12-23 00:41
# ä¼˜åŒ–äº†ä»£ç  2023-12-23 14:21
# V1.0 2023-12-23 16:56
# å±è”½order_pathå­—æ®µä»¥æ¢å¤å¯¹PrismVisionçš„é€‚é…
# å¢åŠ äº†é»‘åå•/ç™½åå•è§„åˆ™å’Œé¡µé¢ç›®å½• 2023-12-23 21:39
# å¢åŠ äº†åœ¨æŒ‡å®šè·¯å¾„è‡ªåŠ¨å¯»æ‰¾æœ€æ–°.ednæ–‡ä»¶çš„åŠŸèƒ½ 2023-12-23 21:52
# å¢åŠ æŒ‡å®šæ—¥æœŸæ–‡ä»¶é€‰å–åŠŸèƒ½ï¼Œå¹¶æ˜¾ç¤ºå½“å‰æ–‡ä»¶åˆ›å»ºæ—¥æœŸå’Œä½“ç§¯ä¿¡æ¯ 2023-12-23 22:35
# ä¼˜åŒ–é¡µé¢ç”Ÿæˆæ—¶é—´ï¼šread_and_parse_edn_fileå æ®äº†å¤§æ–‡ä»¶å¤„ç†çš„80%ä»¥ä¸Šçš„æ—¶é—´ï¼Œä¸å¤ªå®¹æ˜“ä¼˜åŒ– 2023-12-23 23:33
# å°†markdownå›¾ç‰‡æ›¿æ¢æˆå¯ä»¥æ§åˆ¶å°ºå¯¸çš„htmlå›¾ç‰‡ï¼Œå±è”½codeblock 2023-12-24 00:53
# è¡¥å……å¯¹htmlå¯¼å‡ºçš„æ”¯æŒ 2023-12-24 11:38
# æ·»åŠ htmlä¸­å¯¹å­—ä½“å’Œcssç­‰ç¾åŒ–çš„æ”¯æŒ 2023-12-24 16:51
# ä¼˜åŒ–ä»£ç æ˜¾ç¤ºï¼Œä½†ä¼šå¼•èµ·ä»£ç åæœ‰ç¼©è¿›è¡Œçš„æ˜¾ç¤ºå¼‚å¸¸ï¼›è¿™ä¼¼ä¹æ˜¯markdownçš„æ˜¾ç¤ºé€»è¾‘ï¼Œæš‚æ—¶ä¸å¥½è§£å†³ 2023-12-24 19:11
# PrismVisionä¸­å»é™¤å‰ä¸€æ­¥çš„ä»£ç æ˜¾ç¤ºä»¥æ–¹ä¾¿æ•´ä½“å±•ç¤º 2023-12-24 19:49
# ä¿®æ”¹htmlé¡µé¢å¸ƒå±€ï¼Œç›®å‰é™¤ä»£ç æ˜¾ç¤ºå¤–ï¼Œå…¶ä»–åŠŸèƒ½åŸºæœ¬å®Œå¤‡ 2023-12-24 21:03
# å¢åŠ äº†word/pdfçš„å¯¼å‡ºæ”¯æŒï¼Œå…¶ä¸­wordæ”¯æŒè¾ƒå·® 2023-12-23 21:58
# ä¿®å¤åŒ¹é…è¯†åˆ«bugï¼šedn_data = re.sub(r'(:entity/attrs).*?\}\]\}', r'\1', edn_data) 2023-12-25 12ï¼š16
# æ·»åŠ è½¬è¯‘è°·æ­Œå›¾åºŠåˆ°é˜¿é‡Œäº‘/æœ¬åœ°çš„å¯é€‰æ”¯æŒ 2023-12-25 15:21
# æ·»åŠ äº†å¯¹Githubå¤‡ä»½çš„æ”¯æŒ 2023-12-25 16:40
# å°è¯•ä¿®å¤htmlè¡Œå†…ä»£ç æ˜¾ç¤ºå¼‚å¸¸ï¼Œæœªæœ 2023-12-25 18:37
# æ·»åŠ å¼•ç”¨æ–‡æœ¬æ˜¾ç¤ºï¼Œå¹¶ç”¨ä¸‹åˆ’çº¿æ ‡è®°å¼•æ–‡ï¼›ä¼˜åŒ–ä»£ç  2023-12-25 21:07
# é‡æ–°å¯ç”¨code blockï¼Œå½“å‰ä»£ç æ®µä»…æ”¯æŒé¡¶æ ¼æ˜¾ç¤ºï¼Œå‰åä¸€è¡Œå¿…é¡»é¡¶æ ¼ï¼šè¿™æ˜¯markdownçš„ä»£ç æ˜¾ç¤ºè§„èŒƒ 2023-12-25 23:38
# ä¼˜åŒ–å›¾ç‰‡é“¾æ¥![xx]()çš„è¯†åˆ«å’Œhtmlçš„todoæ˜¾ç¤º 2023-12-26 14:34
# ä¸‹ä¸€æ­¥è®¡åˆ’ï¼šæ‰¾å‡ºread_and_parse_edn_file(file_path)è€—æ—¶çš„åŸå›  -> edn_format.loads(edn_data)å‡½æ•°å¤§é‡å ç”¨æ—¶é—´æ‰€è‡´ 2023-12-26 15:17
# ä¼˜åŒ–æ–‡ä»¶è¯»å–å­å‡½æ•° 2023-12-26 16:18
# ä¿®å¤htmlå›¾ç‰‡å±…ä¸­åŒæ­¥bug 2023-12-28 15:10
# ä¼˜åŒ–ä»£ç åˆ†å¸ƒï¼Œåˆ å»æ•ˆæœä¸å¤ªå¥½çš„PDFå’Œdocxå¯¼å‡º 2024-06-17 22:22

import edn_format
import json
import re
from datetime import datetime, timezone, timedelta
import time  # å¯¼å…¥ time æ¨¡å—
import os
import markdown


def get_file_info(filepath): # è·å–æ–‡ä»¶ä¿¡æ¯
    # è·å–æ–‡ä»¶çš„åˆ›å»ºæ—¶é—´
    creation_time = os.path.getctime(filepath)
    formatted_creation_time = datetime.fromtimestamp(creation_time).strftime("%Y-%m-%d %H:%M:%S")

    # è·å–æ–‡ä»¶çš„ä½“ç§¯ï¼ˆå­—èŠ‚ï¼‰ï¼Œå¹¶è½¬æ¢ä¸º MB
    file_size_bytes = os.path.getsize(filepath)
    file_size_mb = file_size_bytes / (1024 * 1024)

    return formatted_creation_time, file_size_mb

def find_latest_edn_file(folder_path, specific_date=None): # é€‰å–æŒ‡å®šæ—¥æœŸçš„.ednæ–‡ä»¶
    latest_time = None
    latest_file = None
    specific_date_time = None
    exact_match_found = False

    if specific_date:
        try:
            specific_date_time = datetime.strptime(specific_date, "%Y-%m-%d").timestamp()
        except ValueError:
            print("æŒ‡å®šæ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œæ ¼å¼åº”ä¸º YYYY-MM-DD")
            return None, False

    for filename in os.listdir(folder_path):
        if filename.endswith(".edn"):
            filepath = os.path.join(folder_path, filename)
            file_time = os.path.getmtime(filepath)

            if specific_date_time:
                midnight_time = datetime.fromtimestamp(file_time).replace(hour=0, minute=0, second=0, microsecond=0).timestamp()
                if midnight_time > specific_date_time:
                    continue

                if midnight_time == specific_date_time:
                    exact_match_found = True

            if latest_time is None or file_time > latest_time:
                latest_time = file_time
                latest_file = filepath
    
    # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
    if latest_file: 
        if exact_match_found:
            print(f"é€‰å®šçš„ .edn æ–‡ä»¶:\n {edn_path}")
        else:
            print(f"æœªæ‰¾åˆ°æŒ‡å®šæ—¥æœŸ ({specific_date}) çš„æ–‡ä»¶ï¼Œé€‰æ‹©æœ€æ¥è¿‘æ—¥æœŸçš„æ–‡ä»¶: \n{latest_file}")

        # è·å–å¹¶æ‰“å°æ–‡ä»¶çš„åˆ›å»ºæ—¶é—´å’Œä½“ç§¯
        creation_time, file_size = get_file_info(latest_file)
        print(f"æ–‡ä»¶åˆ›å»ºæ—¶é—´: {creation_time} æ–‡ä»¶ä½“ç§¯: {file_size:.3f} MB")
    else:
        print("åœ¨æŒ‡å®šæ—¥æœŸä¹‹å‰æ²¡æœ‰æ‰¾åˆ°ä»»ä½• .edn æ–‡ä»¶")

    return latest_file

def read_and_parse_edn_file(file_path): # å¤§æ–‡ä»¶å¤„ç†å¾ˆè€—æ—¶ï¼ï¼ï¼
    with open(file_path, 'r', encoding='utf-8') as file:
        edn_data = file.read()
        # æ•°æ®æ¸…æ´—
        # edn_data = re.sub(r':entity/attrs #{}', '', edn_data)
        ## edn_data = re.sub(r'(:entity/attrs).*?\}\]\}', r'\1', edn_data)
        ## edn_data = re.sub(r'(:entity/attrs) #{\[{.*?}\]}', r'\1', edn_data, flags=re.DOTALL)
        edn_data = re.sub(r'(:entity/attrs)\s*#{\[{(.*?)}\]}', r'\1', edn_data, flags=re.DOTALL) # æ”¯æŒGithub
        edn_data = re.sub(r'#datascript/DB', '', edn_data).replace('#', '**TaG**')

        return edn_format.loads(edn_data)

def convert_edn_to_json(data):
    if isinstance(data, edn_format.immutable_dict.ImmutableDict):
        new_dict = {}
        for k, v in data.items():
            if isinstance(k, list):
                key = tuple(convert_edn_to_json(item) for item in k)  # å°†åˆ—è¡¨è½¬æ¢ä¸ºå…ƒç»„
            else:
                key = convert_edn_to_json(k)
            new_dict[key] = convert_edn_to_json(v)
        return new_dict
    elif isinstance(data, edn_format.immutable_list.ImmutableList):
        return [convert_edn_to_json(v) for v in data]
    elif isinstance(data, edn_format.Keyword):
        return str(data)
    elif isinstance(data, list):
        return [convert_edn_to_json(v) for v in data]
    else:
        return data

def convert_timestamp_to_utc8(timestamp_ms): # è½¬æ¢æ—¶é—´è¿›åˆ¶
    # å°†æ¯«ç§’è½¬æ¢ä¸ºç§’
    timestamp_sec = timestamp_ms / 1000.0
    # å°†æ—¶é—´æˆ³è½¬æ¢ä¸ºUTCæ—¶é—´
    utc_time = datetime.utcfromtimestamp(timestamp_sec)
    # è½¬æ¢ä¸ºUTC+8æ—¶é—´
    utc8_time = utc_time.replace(tzinfo=timezone.utc).astimezone(timezone(timedelta(hours=8)))
    return utc8_time.strftime('%Y-%m-%d %H:%M:%S')

def parse_datoms(datoms):
    block_data = {}
    for datom in datoms:
        if len(datom) != 4:
            continue

        block_id, attribute, value, _ = datom
        if block_id not in block_data:
            block_data[block_id] = {
                "id": block_id,
                "uid": None,
		"create_time": None,
                "page": None,
                "parents": [],
                "children": [],
                "order": None,
                "string": None,
                "heading": 0,  # é»˜è®¤å€¼ä¸º 0
            }

        if attribute == ":block/uid":
            block_data[block_id]["uid"] = value
        elif attribute == ":create/time":
            utc8_time = convert_timestamp_to_utc8(value)
            block_data[block_id]["create_time"] = utc8_time
        elif attribute == ":block/page":
            block_data[block_id]["page"] = value
        elif attribute == ":block/parents":
            block_data[block_id]["parents"].append(value)
        elif attribute == ":block/children":
            block_data[block_id]["children"].append(value)
        elif attribute == ":block/order":
            block_data[block_id]["order"] = value
        elif attribute == ":block/string":
            block_data[block_id]["string"] = value
        elif attribute == ":block/heading":
            block_data[block_id]["heading"] = value

    return [data for data in block_data.values() if data["string"] is not None]

def parse_datoms_for_pages(datoms):
    page_data = {}
    for datom in datoms:
        if len(datom) != 4:
            continue

        block_id, attribute, value, _ = datom

        # ç¡®ä¿block_idåœ¨page_dataä¸­
        if block_id not in page_data:
            page_data[block_id] = {
                "id": block_id,
                "uid": None,
                "title": None,
                "children": [],
            }

        # æå–ç›¸å…³å±æ€§
        if attribute == ":block/uid":
            page_data[block_id]["uid"] = value
        elif attribute == ":node/title":
            page_data[block_id]["title"] = value
        elif attribute == ":block/children":
            page_data[block_id]["children"].append(value)

    # åªè¿”å›æœ‰æ ‡é¢˜ä¸”æœ‰å­é¡¹çš„é¡µé¢
    return [data for data in page_data.values() if data["title"] is not None and data["children"]]

def build_blocks_dict(datoms):
    blocks = {}
    for datom in datoms:
        if len(datom) != 4:
            continue

        block_id, attribute, value, _ = datom
        if block_id not in blocks:
            blocks[block_id] = {
                "id": block_id,
                "uid": None,
                "string": None,
                "children": [],
                "parents": [],
                "order": None,
                # "order_path": [],  # æ–°å¢å­—æ®µ
                "heading": 0,  # é»˜è®¤å€¼ä¸º 0
                "text_align": None,
                "refs": [],
            }

        if attribute == ":block/uid":
            blocks[block_id]["uid"] = value
        elif attribute == ":block/string":
            blocks[block_id]["string"] = value
        elif attribute == ":block/children":
            blocks[block_id]["children"].append(value)
        elif attribute == ":block/parents":
            blocks[block_id]["parents"].append(value)
        elif attribute == ":block/order":
            blocks[block_id]["order"] = value
        elif attribute == ":block/heading":
            blocks[block_id]["heading"] = value
        elif attribute == ":block/text-align":
            blocks[block_id]["text_align"] = value
        elif attribute == ":block/refs":
            blocks[block_id]["refs"] = value

    return blocks

def process_blocks(blocks):
    uid_to_string_map = {block['uid']: block['string'] for block in blocks.values() if block['uid']}
    
    for block in blocks.values():
        if block['string']:
            # Find all occurrences of ((uid)) in the string
            uids_in_string = re.findall(r'\(\((.*?)\)\)', block['string'])
            for uid in uids_in_string:
                if uid in uid_to_string_map:
                    # Replace ((uid)) with the string of the referenced block
                    block['string'] = block['string'].replace(f"(({uid}))", '<u>' + uid_to_string_map[uid] + '</u>')

def build_page_content(block_id, blocks, level=0): # code blockä¿®æ”¹çš„ä½ç½®
    block = blocks[block_id]
    indent = ' ' * (4 * level)
    heading_level = block.get('heading', 0)
    heading_prefix = '#' * (heading_level + 1) + ' ' if heading_level > 0 else ''

    content = block['string']
    
    # ä»£ç æ®µå¤„ç† 
    content = re.sub(r'```(.*?)```', r'```\1\n```\n', content, flags=re.DOTALL)

    # ä»£ç æ®µåˆ é™¤
    # content = re.sub(r'```(.*?)```', r'```css\n deleted code```\n', content, flags=re.DOTALL)
    content = re.sub(r'202*\*\*.*?weathercard', 'year\*\*', content, flags=re.DOTALL)

    # å¦‚æœ :block/text-align ä¸º centerï¼Œåˆ™åœ¨ä¸¤è¾¹æ·»åŠ  <center>
    if block.get('text_align') == 'center': # and not content.startswith('!['):
        content = f"<center>{content}</center>"
        content = content.replace("^^", "<mark>").replace("__", "<i>").replace("**", "<b>")

    # å¦‚æœå­—ç¬¦ä¸²ä»¥ '>' å¼€å¤´ï¼Œæ·»åŠ é¢å¤–çš„æ¢è¡Œç¬¦
    if content.startswith('>'):
        content += '\n'
    comma='- '
    
    # ç¼©è¿›å’Œå†…å®¹ï¼šPrismVisionä¸­éœ€è¦å»é™¤ifè¯­å¥ï¼ï¼ï¼
    # if content.startswith('```'):
    #     content = f"{content}\n"
    # if not content.startswith('```'):
    content = f"{indent}{comma}{heading_prefix}{content}\n"

    for child_id in sorted(block["children"], key=lambda id: blocks[id]["order"]):
        content += build_page_content(child_id, blocks, level + 1)

    return content

def is_page_allowed(page, allowed_uids, allowed_titles, blocked_uids, blocked_titles):
    # å¦‚æœç™½åå•ä¸ä¸ºç©ºï¼Œä¸”é¡µé¢ä¸åœ¨ç™½åå•ä¸­ï¼Œåˆ™è¿”å› False
    if allowed_uids or allowed_titles:
        if page["uid"] not in allowed_uids and page["title"] not in allowed_titles:
            return False

    # å¦‚æœé¡µé¢åœ¨é»‘åå•ä¸­ï¼Œåˆ™è¿”å› False
    if page["uid"] in blocked_uids or page["title"] in blocked_titles:
        return False

    # åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œè¿”å› True
    return True

########################## è¯»å– EDN æ–‡ä»¶ ########################################
################################################################################

# å¯åŠ¨è®¡æ—¶
start_time = time.time()

## åˆå§‹åŒ–å‚æ•°
specific_date=None
blocked_uids = []
blocked_titles = []
allowed_uids = []
allowed_titles = []

## å‚æ•°è®¾å®š
# specific_date = "2022-09-25"  # ä¾‹å¦‚ '2023-12-25'ï¼Œå¦‚æœä¸éœ€è¦æŒ‡å®šæ—¥æœŸï¼Œåˆ™è®¾ä¸º None

# æŒ‡å®šæ–‡ä»¶å¤¹è·¯å¾„è‡ªåŠ¨å¯»æ‰¾æ–‡ä»¶
folder_path = '/Users/lukesky/Library/Application Support/Roam Research/backups/InsightSphere/'
# folder_path = '/Users/lukesky/Library/Application Support/Roam Research/backups/PrismVision/'
# folder_path = '/Users/lukesky/Touch/Git/roam-snapshot/edn/' # folder_path = '/Users/lukesky/å·¥ä½œå°'

# é»‘åå•ä¸ç™½åå•
blocked_uids = ["uid1", "uid2", "uid3"]  # éœ€è¦å±è”½çš„é¡µé¢UIDåˆ—è¡¨
blocked_titles = ["W/S/roam/css", "title2", "title3"]  # éœ€è¦å±è”½çš„é¡µé¢æ ‡é¢˜åˆ—è¡¨
# allowed_uids = ["Xj7YD_MxR", "", "mGBUMYZiW"]  # éœ€è¦æ˜¾ç¤ºçš„é¡µé¢UIDåˆ—è¡¨
# allowed_titles = ["W/S/roam/css","Inbo", "archai",  "å®¡é˜…æµ‹è¯•"]  # éœ€è¦æ˜¾ç¤ºçš„é¡µé¢æ ‡é¢˜åˆ—è¡¨

## å¯¼å‡ºæ–‡ä»¶å¤¹
output_path = '/Users/lukesky/RR/output'  # æ›¿æ¢ä¸ºå®é™…çš„æ–‡ä»¶å¤¹è·¯å¾„

################################################################################
################################################################################


# æŸ¥æ‰¾æœ€æ–°çš„ .edn æ–‡ä»¶
edn_path = find_latest_edn_file(folder_path, specific_date) 
# edn_path = '/Users/lukesky/Touch/Git/roam-snapshot/edn/PrismVision.edn'
# edn_path = '/Users/lukesky/Touch/Git/roam-snapshot/edn/InsightSphere.edn'

# è§£æ EDN æ•°æ® è€—æ—¶22.5s/27s
parsed_data = read_and_parse_edn_file(edn_path)

# è½¬æ¢ä¸ºæ ‡å‡†Pythonæ•°æ®ç»“æ„ è€—æ—¶4s/27s
json_ready_data = convert_edn_to_json(parsed_data)

# è§£æ datoms éƒ¨åˆ† è€—æ—¶0.1s/27s
datoms = json_ready_data.get(":datoms", [])


################## markdown

# è§£ædatomsä»¥è·å–é¡µé¢ä¿¡æ¯
parsed_pages = parse_datoms_for_pages(datoms)

# æ„å»ºå—ä¿¡æ¯å­—å…¸
blocks = build_blocks_dict(datoms)
process_blocks(blocks)

# å¤„ç†æ¯ä¸ªé¡µé¢
pages_content = []
for page in parsed_pages:
    if not is_page_allowed(page, allowed_uids, allowed_titles, blocked_uids, blocked_titles):
        continue
    
    children = page["children"]
    # æ£€æŸ¥æ˜¯å¦åªæœ‰ä¸€ä¸ª child ä¸”è¯¥ child çš„ string ä»…åŒ…å«ç©ºæ ¼
    if len(children) == 1 and not blocks[children[0]]['string'].strip():
        continue  # å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œè·³è¿‡è¿™ä¸ªé¡µé¢
    
    page_content = f"# {page['title']}\n"
    # ç¡®ä¿ç¬¬ä¸€çº§å—æŒ‰ç…§ order æ’åº
    sorted_children = sorted(page["children"], key=lambda id: blocks[id]["order"])
    for child_id in sorted_children:
        page_content += build_page_content(child_id, blocks)
    
    # è¿˜åŸæ¯ä¸ªé¡µé¢çš„ Tag
    page_content = page_content.replace('**TaG**', '#')
    # Typoraè¯­æ³•
    page_content = page_content.replace("^^", "==").replace("__", "_").replace("---", "â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” \n")
    page_content = page_content.replace("{{[[DONE]]}}", "- [x] ").replace("{{[[TODO]]}}", "- [ ] ")
    
    # è°·æ­Œå›¾åºŠè½¬ç§»åˆ°é˜¿é‡Œäº‘/æœ¬åœ°æ–‡ä»¶å¤¹
    # # page_content = re.sub(r'https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FPrismVision%2F(.*?)\?alt=media&token=.*?\)', r'https://ideapply.oss-cn-nanjing.aliyuncs.com/img/\1)', page_content, flags=re.DOTALL) #é˜¿é‡Œäº‘
    # page_content = re.sub(r'https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FPrismVision%2F(.*?)\?alt=media&token=.*?\)', r'/Users/lukesky/roam_image/PrismVision/images/PrismVision/\1)', page_content, flags=re.DOTALL) #æœ¬åœ°

    # å°† Markdown æ ¼å¼çš„å›¾ç‰‡é“¾æ¥è½¬æ¢ä¸º HTML <img> æ ‡ç­¾
    # page_content = re.sub(r'!\[.*?\]\((.*?)\)', r'<img src="\1" style="zoom:30%" />', page_content)
    page_content = re.sub(r'!\[.*?\]\((.*?)\)', r'<img src="\1" width="400px" />', page_content)


    pages_content.append(page_content)

# æ„å»ºç›®å½•ä¿¡æ¯
directory_content = "# ç›®å½•\n\n"
for page in parsed_pages:
    if is_page_allowed(page, allowed_uids, allowed_titles, blocked_uids, blocked_titles):
        directory_content += f"- {page['title']} (UID: {page['uid']}, ID: {page['id']})\n"
directory_content += "\n---\n\n"

page_content = directory_content + '\n'.join(pages_content)
page_content_toc = '[TOC]\n'+ directory_content +'\n'.join(pages_content)

# æŒ‡å®šæ–‡ä»¶å¤¹è·¯å¾„å’Œæ–‡ä»¶å
file_name = 'pages_text_output.md'
file_path = os.path.join(output_path, file_name)

# åˆ›å»ºæ–‡ä»¶å¤¹ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
os.makedirs(output_path, exist_ok=True)

# å°†ç»“æœå†™å…¥æ–‡ä»¶
with open(file_path, 'w', encoding='utf-8') as file:
    file.write(page_content_toc)

################## html

def process_format_content(markdown_content): # å¤„ç†é¡µé¢å†…å®¹ï¼Œè½¬ä¹‰ #Tag  å¤„ç†å¾…åŠäº‹é¡¹
    # å¤„ç†é¡µé¢å†…å®¹ï¼Œè½¬ä¹‰ #Tag
    markdown_content = re.sub(r'#(\w+)', r'ğŸ·ï¸\1', markdown_content)
    markdown_content = re.sub(r'#\.(\w+)', r'ğŸ·ï¸.\1', markdown_content)
    markdown_content = re.sub(r'#\[\[(\w+)', r'ğŸ·ï¸\[\[\1', markdown_content)
    markdown_content = re.sub(r'==(.*?)==', r'<mark>\1</mark>', markdown_content)
    markdown_content = re.sub(r'~~(.*?)~~', r'<del>\1</del>', markdown_content, flags=re.DOTALL)
    markdown_content = re.sub(r'```(.*?)```', r'<pre><code>\1</code></pre>\n', markdown_content, flags=re.DOTALL)
    # markdown_content = re.sub(r'`\{\{.*?\}\}`', r'`\{\{\1\}\}`\n', markdown_content, flags=re.DOTALL) # ä¿®å¤è¡Œå†…ä»£ç æ¢è¡Œé—®é¢˜
    # markdown_content = re.sub(r'}}\s`\n', r'}}`\n\n' , markdown_content, flags=re.DOTALL)
    # markdown_content = re.sub(r'`\n', r'`\n\n' , markdown_content, flags=re.DOTALL) # ä¿®å¤äº†è¡Œå†…ä»£ç æ¢è¡Œé—®é¢˜

    # æ›¿æ¢æœªå®Œæˆçš„å¾…åŠäº‹é¡¹
    markdown_content = re.sub(r'\- \[ \]', r'- <input type="checkbox" class="todo-checkbox" disabled>', markdown_content)
    # æ›¿æ¢å·²å®Œæˆçš„å¾…åŠäº‹é¡¹
    markdown_content = re.sub(r'\- \[x\]', r'- <input type="checkbox" class="todo-checkbox" checked disabled>', markdown_content)
    return markdown_content

# å¤„ç†é¡µé¢å†…å®¹ï¼Œè½¬ä¹‰ #Tag å¤„ç†å¾…åŠäº‹é¡¹
page_content = process_format_content(page_content)

# è½¬æ¢ Markdown ä¸º HTML
html_content = markdown.markdown(page_content)
html_content = html_content.replace('ğŸ·ï¸', '#')

# è‡ªå®šä¹‰CSSæ ·å¼
custom_css = """
    @font-face {
        font-family: "CangErJinKai01-9128-W03-4";
        src: url('https://ideapply.oss-cn-nanjing.aliyuncs.com/fonts/CangErJinKai01-9128-W03-4.otf') format("opentype");
    }
    body {
        font-family: "CangErJinKai01-9128-W03-4", sans-serif;
        line-height: 1.6;
        font-size: 17px;
        padding: 1rem;
        margin-left: auto;  /* å·¦è¾¹è·è‡ªåŠ¨ */
        margin-right: auto; /* å³è¾¹è·è‡ªåŠ¨ */
        width: 70%;        /* è®¾å®šä¸€ä¸ªå®½åº¦ */
        max-width: 1024px;
    }
    h1, h2, h3, h4, h5, h6 {
        margin-top: 1.2em;
        margin-bottom: 0.6em;
    }
    p {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }
    ul, ol {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        padding-left: 20px;
    }

    .todo-checkbox {
        margin-right: 0.25em;
    }

    /* è‡ªåŠ¨æ¢è¡Œ */
    body {
        word-wrap: break-word; /* æ—§çš„æµè§ˆå™¨ */
        overflow-wrap: break-word; /* æ–°çš„æ ‡å‡† */
    }
    pre {
        white-space: pre-wrap; /* å…è®¸åœ¨é¢„æ ¼å¼åŒ–æ–‡æœ¬ä¸­è‡ªåŠ¨æ¢è¡Œ */
    }

    /* è‡ªé€‚åº”é¡µè¾¹è· */
    #write {
        max-width: 860px;  /* è®¾ç½®å†…å®¹åŒºçš„æœ€å¤§å®½åº¦ */
        margin: 0 auto;    /* ä¸Šä¸‹ä¿æŒä¸º0ï¼Œå·¦å³è‡ªåŠ¨è°ƒæ•´ï¼Œå®ç°å±…ä¸­ */
        padding: 30px;     /* å†…è¾¹è·ï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ */
        padding-bottom: 100px; /* åº•éƒ¨å†…è¾¹è· */
    }

    /* å“åº”å¼è®¾è®¡ï¼Œæ ¹æ®ä¸åŒå±å¹•å®½åº¦è°ƒæ•´æœ€å¤§å®½åº¦ */
    @media only screen and (min-width: 1400px) {
        #write {
            max-width: 1024px; /* å¤§å±å¹•æ—¶çš„æœ€å¤§å®½åº¦ */
        }
    }

    @media only screen and (min-width: 1800px) {
        #write {
            max-width: 1200px; /* æ›´å¤§å±å¹•æ—¶çš„æœ€å¤§å®½åº¦ */
        }
    }

    """

html_with_custom_font = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style>{custom_css}</style>
    </head>
    <body>
    {html_content}
    </body>
    </html>
    """

# æŒ‡å®šæ–‡ä»¶å¤¹è·¯å¾„å’Œæ–‡ä»¶å
file_name = 'pages_html_output.html'
file_path = os.path.join(output_path, file_name)

# åˆ›å»ºæ–‡ä»¶å¤¹ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
os.makedirs(output_path, exist_ok=True)

# ä½¿ç”¨ UTF-8 ç¼–ç å°† HTML å†™å…¥æ–‡ä»¶
with open(file_path, 'w', encoding='utf-8') as file:
    file.write(html_with_custom_font)


# ç»“æŸè®¡æ—¶å¹¶æ‰“å°è¿è¡Œæ—¶é—´
end_time = time.time()
print(f"Program finished in {end_time - start_time:.3f} seconds")
